## Ejercicio 1
#### a)

idtentry3(98)


_isr98:
    pushad
    
    push eax

    push edi
    push esi
    push ebx
    push edx
    push ecx

    call swap   

    movd [esp + offset_edi], eax
    movd [esp + offset_esi], eax
    movd [esp + offset_ebx], eax
    movd [esp + offset_edx], eax
    movd [esp + offset_ecx], eax

    popad
    
    iret



la funcion va a retornar el array "retorno" de longitud 5 (cantidad de registros), el orden va a ser [edi, esi, ebx, edx, ecx]


swap(id,ecx,edx,ebx,esi,edi){
    
    uint32_t retorno 
    sched_entry_t tarea_destino = sched_tasks[id]
    while(! tarea_destino.wants_swap[current_task]){
    }
    int16_t tss_selector = tarea_destino.selector
    tss_descriptor_t* descriptor = gdt[tss_selector * 8]
    tss_t* tss_destino = descriptor.base31_24 | (descriptor.base23_16 >> 23) | (descriptor.base15_0 >> 15) 
    
    uint32_t* stack_3_destino = tss_destino.esp   
    
    retorno[0] = stack_3_destino[0];
    retorno[1] = stack_3_destino[1];
    retorno[2] = stack_3_destino[4];
    retorno[3] = stack_3_destino[5];
    retorno[4] = stack_3_destino[6];
    
    stack_3_destino[0] = edi
    stack_3_destino[1] = esi
    stack_3_destino[4] = ebx
    stack_3_destino[5] = edx
    stack_3_destino[6] = ecx

    return retorno
}

#### b)

idtentry3(99)

_isr99:
    pushad

    push eax

    push edi
    push esi
    push ebx
    push edx
    push ecx
    call swap_now

    popad
    iret


swap_now(id,ecx,edx,ebx,esi,edi){

    uint32_t retorno 
    sched_entry_t tarea_destino = sched_tasks[id]
    if(! tarea_destino.wants_swap[current_task]){
        int16_t tss_selector = tarea_destino.selector
        tss_descriptor_t* descriptor = gdt[tss_selector * 8]
        tss_t* tss_destino = descriptor.base31_24 | (descriptor.base23_16 >> 23) | (descriptor.base15_0 >> 15) 
        
        uint32_t* stack_3_destino = tss_destino.esp   
        
        retorno[0] = stack_3_destino[0];
        retorno[1] = stack_3_destino[1];
        retorno[2] = stack_3_destino[4];
        retorno[3] = stack_3_destino[5];
        retorno[4] = stack_3_destino[6];
        
        stack_3_destino[0] = edi
        stack_3_destino[1] = esi
        stack_3_destino[4] = ebx
        stack_3_destino[5] = edx
        stack_3_destino[6] = ecx
    }

    return retorno
}


## Ejercicio 2

#### a)

Podriamos agregar un llamado a la función acknowledge_changes() definida de la siguiente manera

void acknowledge_changes(uint8_t changed, tss_t tss){

    pd_entry_t* pd = (pd_entry_t*) cr3_to_dir(tss.cr3)                      ;buscamos el directorio de la tarea

    uint16_t pdi = virt_to_dir(0xC0001C0DE)                                 ;obtenemos el indice del directorio de la direcc virtual
    uint16_t pti = virt_to_table(0xC001C0DE)                                ;obtenemos el indice de la table de la direcc virtual

    pt_entry_t* page_table = (pt_entry_t*) pd[pdi].pt << 12                 ;obtenemos la tabla de la direcc virtual

    pt_entry_t page_table_entry = page_table[pti].page << 12                ;buscamos la pagina de la dirección virtual

    page_table_entry[virt_page_offset(0xC001C0DE)] = changed;               ;le asignamos en el offset de la direcc el valor que corresponda
}

Bastaria con agregar en el swap justo antes del return lo siguiente:

    sched_entry_t tarea_actual = sched_tasks[current_task]
    int16_t tss_selector_actual = tarea_actual.selector
    tss_descriptor_t* descriptor_actual = gdt[tss_selector_actual * 8]
    tss_t* tss_actual = descriptor_actual.base31_24 | (descriptor_actual.base23_16 >> 23) | (descriptor_actual.base15_0 >> 15) 
    acknowledge_changes(1, tss_actual)  

En el caso de swap_now:

    sched_entry_t tarea_actual = sched_tasks[current_task]
    int16_t tss_selector_actual = tarea_actual.selector
    tss_descriptor_t* descriptor_actual = gdt[tss_selector_actual * 8]
    tss_t* tss_actual = descriptor_actual.base31_24 | (descriptor_actual.base23_16 >> 23) | (descriptor_actual.base15_0 >> 15) 
    if(! tarea_destino.wants_swap[current_task]){
        ...
        acknowledge_changes(1, tss_actual)  
    }
    else{
        acknowledge_changes(0, tss_actual)  
    }