
al ser una rutina llamada por codigo de usuario vamos a tener que declararla con acceso minimo lvl 3 con:

idtentry3(99)

Ademas, necesitamos crear una variable global que nos permita saber si la tarea a ejecutar tiene que ser wipeada en el cambio

bool wipe = false

Definimos la interrupcion de la siguiente forma:
isr99:
    pushad

    call should_wipe_accessed

    popad
    iret

void should_wipe_accessed(){
    wipe = true;
}
    
Ahora, tenemos que redefinir la interrupcion del clock
_isr32:
    pushad

    call pic_finish1
    call next_clock
    
    call sched_next_task
    cmp ax, 0
    je .fin

    str bx
    cmp ax, bx
    je .fin
    
    push ax ;pusheamos el selector de la nueva tarea
    call wipe_all

    mov word [sched_task_selector], ax
    jmp far [sched_task_offset]

    .fin:
    popad
    iret


wipe_all(uint16_t selector){
    if(wipe){

        tss_t* tss = gdt[selector * 8]
        uint16_t cr3 = tss.cr3
        pd_entry_t* pd = CR3_TO_PAGE_DIR(cr3)
        for(int i = 0; i < PAGE_SIZE; i++){
            pt_entry_t* page_table =pd[i].pt
            for(int j = 0; j < PAGE_SIZE; j++){
                page_table[j].attrs = accesed_false
            }
        }
    }
}


//idea: buscar la lista de tasks, acceder a su tss, usar su cr3 para obtener los mapeos y buscar la direcc virtual

uint32_t getMappings(uint32_t virtual, gdt_entry_t* gdt){

    for(int i = 0; i < sched_tasks.size; i++){
        uint16_t selector = sched_tasks[i].selector;

        tss_descriptor* gdt_idt = gdt[selector * 8]

        tss_t* tss_base = gdt_idt.base31_24 & mask0 | gdt_idt.base23_16 & mask1 | gdt_idt15_0 & mask2 //donde las mascaras ponen en 0 todo lo que no sean los bits marcados XX_YY (desde XX hasta YY)
    
        uint32_t cr3 = tss_base.cr3

        pd_entry_t* pd = (pd_entry_t*) cr3_to_page_dir(cr3)
        if(!pd.p){continue}
        pt_entry_t* page_table = pd.pt[virt_page_table(virtual)]
        if(!page_table.p){continue}
        contador += 1
    }


}