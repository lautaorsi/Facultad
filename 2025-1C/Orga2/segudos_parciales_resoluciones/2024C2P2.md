# Primer Ejercicio

### a) void buffer_dma(pd_entry_t* pd) que dado el page directory de una tarea realice el mapeo del buffer en modo DMA

void buffer_dma(pd_entry_t* pd){
    mmu_map_page((uint32_t) pd, 0xBABAB000, 0xF151C000, MMU_P | MMU_U)
}

### b) void buffer_copy(pd_entry_t* pd, paddr_t phys) que dado el page dir de una tarea realce la copia del buffer a la direcc fisica pasada y la mapee

void buffer_copy(pd_entry_t* pd, paddr_t phys){
    mmu_copy_page(phys, 0xF151C000)
    mmu_map_page((uint32_t pd), 0xBABAB000, phys, MMU_P|MMU_U|MMU_W)
}


# Segundo Ejercicio

### programar la rutina que atendera la interrupcion que el lector de cartuchos generara al terminar de llenar el buffer

    isr40:

    pushad

    push ecx
    call deviceready

    popad 
    iret

deviceready: 

    deviceready(uint32_t ecx){

    for(int i = 0; i < tss_tasks.size; i++){
        tss_t task_sel = tss_tasks[i]; 
        uint32_t cr3 = task_sel.cr3;
        
        pd_entry_t* pd = CR3_TO_PAGE_DIR(cr3);

        pt_entry_t* pt = pd[VIRT_PAGE_DIR(0xACCE50)]

        pt_entry_t page = pt[VIRT_PAGE_TABLE(0xACCE50)]

        uint8_t acceso = (uint8_t) *page.pag

        if(acceso == 1){
            buffer_dma(pd)
        }  
        if(acceso == 2){
            mmu_unmap_page(cr3, 0xBABAB000)
            paddr_t nueva_pag = mmu_next_free_user_page()
            
            mmu_map_page(cr3, ecx, nueva_pag, MMU_P|MMU_U|MMU_W)

            buffer_copy(pd, 0xBABAB000)
        }
    }

}


IDTENTRY3(98)
_isr98:
    
    pushad
    
    call deshabilitarAcceso

    popad

    iret

IDTENTRY3(99)
_isr99:
    
    pushad
    
    push ecx
    call habilitarAccesos
    
    popad

    iret

deshabilitarAcceso(){
    uint8_t* dir_acceso = 0xACCE50
    *dir_acceso = 0
}

habilitarAcceso(uint32_t ecx){
    uint8_t* dir_acceso = 0XACCE50
}